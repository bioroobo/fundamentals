# операции языка

print("""
Операция 5-7: сложениe положительного числа и отрицательного числа,
представленного в дополнительном коде 

1) Прямой код числа 5: 0 000 0101
2) Формирование дополнительного кода числа -7.
    Прямой код : 1 000 0111
    Инверсия : 1 111 1000
    Добавление единицы: 1 111 1001
3) Операция сложения (пять минус семь).

     0 000 0101
   + 1 111 1001
    --------------
     1 111 1110

4) 1 111 1110 минус 1 = 1 111 1101 инверсия в прямой код: 10 = 2 в десятичной.     

""")


print('---------------------------')

a,b,c=2,5,9
print('множественное присваивание: a,b,c=2,5,9')
print()

print('2 в степени 3: ', 2**3)
print('2 в степени 3 и результат в степени 4: ', (2**3)**4)
print('2 в степени результата: 3 в степени 1 со скобками: ', 2**(3**1))
print('2 в степени результата: 3 в степени 1 без скобок: ', 2**3**1)
print('квадратный корень числа 25: ', 25**0.5)

print('\nунарный минус: ', -255)

print('\nделение:')
print('дробное (десятичное): 10/3 =', 10/3)
print('целое от деления: 10//3 =', 10//3)
print('остаток от деления (по модулю 3): 10%3 =', 10%3)
print('дробное (десятичное): -10/3 =', -10/3)
print('целое от деления: -10//3 =', -10//3)
print('остаток от деления (по модулю 3): -10%3 =', -10%3)
print('остаток от деления (по модулю 3): 10%-3 =', 10%-3)

print('---------------------------')

print('\n==== БИТОВЫЕ ОПЕРАЦИИ ====\n')

print('Битовая операция НЕ: ~ ')
print('   переводит положительное число в дополнительный код, а отрицательное в прямой код')
print()

a=2
print('a=',a, 'bin(a)=',bin(a))
print('~a=',~a, 'bin(~a)=',bin(~a))
print()

a=4
print('  a= ',a,  'bin(  a)= ',bin(a))
n=~a
print(' ~a=',n,  'bin( ~a)=',bin(n))
print('~~a= ',~n, 'bin(~~a)= ',bin(~n))
print()

a=-1
print('a=',a, 'bin(a)=',bin(a))
print('~a=',~a, 'bin(~a)=',bin(~a))
print()

b=-0b11111111
print('b=',bin(b), 'int(b)=',int(b))
print('b=',bin(b+1), 'int(b)=',int(b+1))

print('')
print('Битовая операция И: &')
print('\n   применяется для проверки какой бит включен \n')
flags = 5
mask = 4 # в двоичной системе 4 это 100 - во втором разряде единица (разряды с нуля)
#проверим, содержится ли в 5 во втором разряде единица (разряды с нуля)
print('flags=',flags , 'mask=', mask, 'flags & mask: ', flags & mask)
if flags & mask == mask:
    print('число 5 во втором разряде двоичного представления содержит единицу (разряды с нуля)')

print('\n   применяется для вЫключения битов \n')
flags = 13 # == 0b1101
mask = 5   # == 0b0101
print('flags=', bin(flags))
print('mask=', bin(mask))
flags &= ~mask   # flags = flags & ~mask # в флагах выключили нулевой и второй разряды
print('применили &,~')
print('flags=', bin(flags), '==', flags)
# flags получился равным 8 - это не разница, это совпадение

print('')
print('Битовая операция ИЛИ: |')
print('\n   применяется для Включения битов \n')
flags = 8 #0b1000
mask = 3 #b0101 
print('flags=', bin(flags), '==', flags)
print('mask=', bin(mask),  '==', mask)
flags |= mask #flags = flags | mask   # включение нулевого и первого бита
print('применили |')
print('flags=', bin(flags), '==', flags) #то, что 8+3=11 это совпадение, побитовая операция | не является сложением

print('')
print('Битовая операция XOR: ^')
print('\n   применяется для шифрования информации \n')
flags = 9 #0b1000
mask = 1 #b0101 
print('flags=', bin(flags), '==', flags)
print('mask=', bin(mask),  '==', mask)
flags ^= mask #flags = flags ^ mask   #
print('применили ^')
print('flags=', bin(flags), '==', flags, 'переключили биты') #
flags ^= mask #flags = flags ^ mask   # 
print('flags=', bin(flags), '==', flags, 'применили ^ и вернули в исходное состояние') #

print('')
print('Приоритет битовых операций:')
print('~')
print('&')
print('| ^')
print('')

print('\n==== ОПЕРАЦИИ СДВИГА ====\n')
print('>> N смещение вправо на N бит - это целочисленное деление на 2 (остаток отбрасывается) N-е число раз')
print('<< N смещение бит влево на N бит - это умножение на два N-е число раз')
print('')

x = 9
print('x=', bin(x), '==', x)
x >>= 1 # x = x >> 1
print('x>>1=', bin(x), '==', x)
x <<= 1 # x = x >> 1
print('x>>1=', bin(x), '==', x)


